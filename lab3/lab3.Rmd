---
title: "Change Analyses"
author: "[Xiuyu Cao](https://github.com/xiuyucao)"
date: "Nov 6, 2023"
output: html_document
---

******************************************************
## Introduction
In this study, 

******************************************************
## Needed Packages
```{r import packages, results='hide'}
library(dplyr)  # for working with dataframes
library(lubridate)  # for working with time data
library(ggplot2)  # for plotting
library(gganimate)  # for plotting animated figures
```

******************************************************
## Data Preparing
The social media data used here is from [Flickr](https://www.flickr.com). They are photos taken in Michigan in recent twenty years. First read the data.
```{r read data}
MichFlickr <- read.csv('../data/lab3/MichiganFlickr.csv')  # read the csv file
head(MichFlickr)  # show the first few lines of the data
```

As we can see, the `dateupload` attribute is a huge integer. It represents the upload time in seconds from 1970-01-01. We need to convert it to a legible format using the functions in the `lubridate` package. The `as.POSIXct()` function can be used to turn the continuous seconds into a legible time formate, and the `as.Date()` function can be used to set the format of the time data.
```{r handle datetime data}
MichFlickr$dateupload <- as.POSIXct(MichFlickr$dateupload, origin='1970-01-01')  # change seconds into a legible time data
# MichFlickr$date <- as.Date(format(MichFlickr$date, format='%Y-%m-%d'))  # set date format
# separately create year, month, day, hour, and minute attribute
MichFlickr$year <- year(MichFlickr$dateupload)
MichFlickr$month <- month(MichFlickr$dateupload, label = TRUE)
MichFlickr$day <- day(MichFlickr$dateupload)
MichFlickr$hour <- hour(MichFlickr$dateupload)
MichFlickr$minute <- minute(MichFlickr$dateupload)
```
The `predict_Na` attribute gives an index of how possible the picture is a picture of nature. Let's say if `predict_Na`$>0.6$, then it is likely to be a photo of nature.
```{r get whether nature}
# set nature threshold and create an attribute telling whether this is a photo of the nature
MichFlickr$Nature<- MichFlickr$predict_Na > 0.6
```
Also, for future spatial analyses, I need the Michigan's border data. This can be downloaded through the `map_data()` function in the `ggplot2` package.
```{r get MI border}
states <- map_data("state")
mich <- subset(states, region == "michigan")  # method 1
mich <- states %>%  # method 2
  filter(region == "michigan")
counties <- map_data("county")
mich_county <- subset(counties, region == "michigan")

ggplot(data = mich) + 
  geom_polygon(aes(x = long, y = lat), fill = "palegreen", color = "black") + 
  coord_fixed(1.3)  # make the x 1.3 times greater than y

# get rid of the weird line
# see the variable group
# mich=filter(mich, group==23)
pmich <- ggplot(data = mich, mapping=aes(x = long, y = lat, group = group)) + 
  coord_fixed(1.3) + 
  geom_polygon(color = "black", fill = "orange") +
  theme_classic() +
  # add the counties
  geom_polygon(data = mich_county, fill = NA, color = "white") +
  geom_polygon(color = "black", fill = NA) +   # get the state border back on top
  # omit the gratitude
  theme_void() + 
  geom_polygon(data = mich_county, fill = NA, color = "white") +
  geom_polygon(color = "black", fill = NA) # get the state border back on top
pmich
```

******************************************************
## Noise Reduction
Social media data include various sources of noise related to the frequency of sharing photographs that can obscure meaningful patterns. Here I will develop a technique for noise reduction that surpasses basic filtering methods.

### Noise Reduction 1

### Noise Reduction 2

### Noise Reduction 3

******************************************************
## Plot Time Series
For plotting, first create a new table `daily_photography` to store the photo count of each day.
```{r get photo count}
MichFlickr$count<- 1  # set count attribute for adding up
daily_photography <- MichFlickr %>%
  group_by(date) %>% # group by the date column
  summarise(total_photos=sum(count)) %>%  # sum the grouped count
  na.omit()  # get rid of the NAs
head(daily_photography)
```
Using `ggplot()`, we can plot the time series data.
```{r}
# set time range
min <- as.Date('2005-1-1')
max <- NA
# plot
p <- ggplot(daily_photography, aes(x = date, y = total_photos)) +  # set x and y axes
  geom_line(color = "#00AFBB", linewidth = 1)  # plot line
  scale_x_date(date_labels = "%b")  # set date labels to abbreviation of months
p +scale_x_date(limits = c(min, max))  # show plot
# smooth the data
p + stat_smooth(method = "loess", formula = y ~ x, size = 1) + scale_x_date(limits = c(min, max))
# Smooth the data based on a spline function
p + geom_smooth(method = lm, formula = y ~ splines::bs(x, 3), se = FALSE) + scale_x_date(limits = c(min, max))
```

Graph different categories of data. e.g. Nature & non-nature
```{r}
daily_nature <- MichFlickr %>%
  mutate(day = as.Date(date, format="%Y-%m-%d")) %>%
  group_by(day, Nature) %>% # group by the day column
  summarise(total_photos=sum(count)) 
ggplot(daily_nature, aes(x = day, y = total_photos)) + 
  geom_line(aes(color = Nature), size = 1) +
  scale_color_manual(values = c("#00AFBB", "#E7B800")) +
  scale_x_date(limits = c(min, max)) +
  theme_minimal()
```

Analyze the monthly pattern of the sharing photograph through Flickr.
```{r}
daily_monthly <- daily_photography %>%
    mutate(month =  month(date, label = TRUE, abbr = FALSE),  # create month attribute
           year  = year(date)) %>%  # create year attribute
    group_by(year,month) %>%  # group the table by year and month attribute
    summarise(total.qty = sum(total_photos))  # get the sum of each month
head(daily_monthly,20)
# plot the data
daily_monthly  %>%
    filter(year > 2004)  %>%  # keep rows that match the condition
    ggplot(aes(x = month, y = total.qty, group = year)) +
    geom_line(aes(color = as.factor(year))) +  # use as.factor() to make the year variable categorical
    scale_color_discrete() + 
    labs(title = "Total Flickr Photographs for Michigan", x = "", y = "Total Photographs",
         subtitle = "Activity is highest for the summer months") +
   theme_classic()
```

Do a similar week analysis
```{r}
weekly <- daily_photography %>%
    mutate(weekday =  wday(date, label = TRUE, abbr = FALSE),
           year  = year(date)) %>%
    group_by(year,weekday) %>%
    summarise(total.qty = sum(total_photos)) 
weekly  %>%
    filter(year > 2004)  %>% 
    ggplot(aes(x = weekday, y = total.qty, group = year)) +
    geom_line(aes(color = as.factor(year))) +
    scale_color_discrete() + 
    labs(title = "Total Flickr Photographs for Michigan", x = "", y = "Total Photographs",
         subtitle = "Activity is highest on the weekends") +
  theme_bw()
```

Using `ggpmisc` package to analyze the peaks in time series
```{r}
library(ggpmisc)
daily_nature_only <- MichFlickr %>%
 mutate(year = year(date), 
        month =  month(date, label = TRUE, abbr = FALSE)) %>%
  filter(Nature == TRUE) %>%
  group_by(date, year, month) %>% # group by the day column
  summarise(total_photos=sum(count)) 

daily_nature_only  %>%  
    filter(year == '2011' & month=='December')  %>% 
ggplot(aes(x = as.POSIXct(date), y = total_photos), as.numeric = FALSE) + 
  geom_line() + 
  stat_peaks(colour = "red") +
  stat_peaks(geom = "text", colour = "red", angle = 45,
               vjust = 1.5, hjust = 1,  x.label.fmt = "%d%B") +
  stat_valleys(colour = "blue") +
 stat_valleys(geom = "text", colour = "blue", angle = 45,
             vjust = 0.5, hjust = 0.5,  x.label.fmt = "%d%B")
```

## Animating Spatial Data


## Check the data we want to animate
```{r}
library(tidyverse)
filtered_data <- MichFlickr %>%
filter(str_detect(str_to_lower(title), "snow"))
pmich+
geom_point(data = test, aes(longitude, latitude), inherit.aes = FALSE)

pmich+
geom_point(data = filtered_data, aes(longitude, latitude), inherit.aes = FALSE)
```

Now we can process data that we want to animate
```{r}
# remember to add other map elements
#min <- as.Date("2008-01-01")
#max  <- as.Date("2015-01-01")
animateMich <- MichFlickr %>% 
  filter( date >= as.Date('2010-01-01') & date <= as.Date('2010-12-31') & Nature=='TRUE')

animateMich <- filtered_data
animateMich <- filtered_data %>% 
  filter( date >= as.Date('2010-01-01') & date <= as.Date('2010-12-31') & Nature=='TRUE')


p2 <-pmich + theme_void() + 
  geom_polygon(data = mich_county, fill = NA, color = "white") +
  geom_polygon(color = "black", fill = NA) + 
  geom_point(data = animateMich, aes(longitude, latitude), inherit.aes = FALSE) +
  labs(title = '{frame_time}') +
  transition_time(year) 
animate(p2 + shadow_wake(0.1), fps=5)
```

There doesn't seem to be any distinguishable pattern. Further filtering of the data is needed.






